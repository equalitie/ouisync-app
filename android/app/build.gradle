import java.util.regex.Matcher
import java.util.regex.Pattern

plugins {
    id "com.android.application"
    id "kotlin-android"
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id "dev.flutter.flutter-gradle-plugin"
}

def properties = new Properties()
rootProject.file("local.properties").withInputStream { properties.load(it) }

def keystoreProperties = new Properties()
def keystorePropertiesFile = rootProject.file('../secrets/android/key.properties')
if (keystorePropertiesFile.exists()) {
    keystorePropertiesFile.withInputStream { keystoreProperties.load(it) }
}

android {
    namespace = "org.equalitie.ouisync"
    compileSdk = 34
    ndkVersion = "27.0.12077973"

    // Fix for:
    //
    // Inconsistent JVM-target compatibility detected for tasks 'compileDebugJavaWithJavac'
    // (1.8) and 'compileDebugKotlin' (17).
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17
    }

    lint {
        checkReleaseBuilds false
        disable 'InvalidPackage'
    }

    // Suffix to append to the application id, name and version. This allows installing multiple
    // versions of the app on the same device (e.g., production and development).
    def appSuffix = System.getenv("APP_SUFFIX") ?: properties.getProperty("app.suffix")

    defaultConfig {
        def appId = "org.equalitie.ouisync"

        applicationId = appId
        resValue "string", "app_name", "Ouisync"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = 21
        targetSdk = 35
        versionCode = flutter.versionCode
        versionName = flutter.versionName
        multiDexEnabled = true

        if (appSuffix != null) {
            applicationIdSuffix = ".$appSuffix"
            versionNameSuffix = "-$appSuffix"
            resValue "string", "app_name", "Ouisync $appSuffix"
        }
    }

    signingConfigs {
        release {
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
            storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null
            storePassword keystoreProperties['storePassword']
        }
    }

    buildTypes {
        release {
            if (keystorePropertiesFile.exists()) {
                signingConfig signingConfigs.release
            } else {
                signingConfig signingConfigs.debug
            }
        }

        debug {
            android.packagingOptions.doNotStrip "**.so"
        }
    }

    flavorDimensions "releaseType"
    productFlavors {
        production {
            dimension "releaseType"
        }
        nightly {
            dimension "releaseType"
            applicationIdSuffix ".nightly"
        }
        unofficial {
            dimension "releaseType"
            applicationIdSuffix ".unofficial"
        }
    }

    // Flutter building will exit with an incomprehensive error if the flavor
    // is not specified. So in this function we do our own check if the
    // --flavor parameter was used and tell the user that it needs to be set if
    // it's not.
    checkFlavorParameter(getCurrentFlavor(), productFlavors)

}

flutter {
   source = "../.."
}

// Generate images in `android/src/main/res/mipmap-*/` based on those in `assets/
task generateResourceImages() {
    def images = [
        "ic_launcher.png": [
            "hdpi": "72x72",
            "mdpi": "48x48",
            "xhdpi": "96x96",
            "xxhdpi": "144x144",
            "xxxhdpi": "192x192",
        ],
        "ic_launcher_background.png": [
            "hdpi": "162x162",
            "mdpi": "108x108",
            "xhdpi": "216x216",
            "xxhdpi": "324x324",
            "xxxhdpi": "432x432",
        ],
        "ic_launcher_foreground.png": [
            "hdpi": "162x162",
            "mdpi": "108x108",
            "xhdpi": "216x216",
            "xxhdpi": "324x324",
            "xxxhdpi": "432x432",
        ],
        "ic_launcher_round.png": [
            "hdpi": "72x72",
            "mdpi": "48x48",
            "xhdpi": "96x96",
            "xxhdpi": "144x144",
            "xxxhdpi": "192x192",
        ],
    ]

    def imagemagick

    def Os = org.apache.tools.ant.taskdefs.condition.Os

    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        imagemagick = 'magick'
    } else {
        imagemagick = 'convert'
    }

    images.each { file, resolutions ->
        resolutions.each { resName, dimensions ->
            exec {
                // TODO: With these `{in,out}put.file` lines I'd like gradle to not re-generate the output files
                // if input files did not change, but changing the paths don't result in an error, so I'm not sure
                // the lines do anything useful.
                inputs.file "../../assets/$file"
                outputs.file "src/main/res/mipmap-$resName/$file"
                // PWD is `ouisync-app/android/app/`
                commandLine imagemagick, "../../assets/$file", "-resize", dimensions, "src/main/res/mipmap-$resName/$file"
            }
        }
    }
}

gradle.projectsEvaluated {
    preBuild.dependsOn('generateResourceImages')
}

// Check if the user provided the `--flavor=` argument.
def checkFlavorParameter(String currentFlavor, availableFlavors) {
    def availableFlavorNames = availableFlavors.collect { it.name }

    if (currentFlavor == null) {
        if (availableFlavors.empty) {
            return
        }
        throw new GradleException("Missing '--flavor=${availableFlavorNames}' argument.")
    }

    if (!availableFlavorNames.contains(currentFlavor)) {
        throw new GradleException("Unrecognized flavor '${currentFlavor}'. Use one from ${availableFlavorNames}.")
    }
}

// Return the current flavor or null.
def getCurrentFlavor() {
    String taskRequests = gradle.startParameter.taskRequests.toString()

    Pattern pattern = Pattern.compile("(assemble|bundle)(\\w+)(Release|Debug)")
    Matcher matcher = pattern.matcher(taskRequests)

    if (matcher.find()) {
        return matcher.group(2).toLowerCase()
    } else {
        return null
    }
}
